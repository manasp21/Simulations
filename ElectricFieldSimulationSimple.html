<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electric Field Center Analysis - 6-Wire Transmission Line</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .canvas-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .simulation-panel {
            flex: 1;
        }
        .plot-panel {
            flex: 1;
        }
        canvas {
            border: 1px solid #333;
            display: block;
            margin: 0 auto;
        }
        #fieldCanvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 70%, #C8D6C8 100%);
        }
        #plotCanvas {
            background: white;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .control-group {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .control-group h4 {
            margin-top: 0;
            color: #333;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button.off {
            background-color: #f44336;
        }
        button.off:hover {
            background-color: #da190b;
        }
        .parameter {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 180px;
            font-weight: bold;
        }
        input[type="range"] {
            width: 200px;
            vertical-align: middle;
        }
        .value-display {
            display: inline-block;
            width: 60px;
            text-align: right;
            font-family: monospace;
        }
        .info {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            font-size: 14px;
        }
        .formula {
            font-family: 'Courier New', monospace;
            background-color: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
            overflow-x: auto;
        }
        .panel-title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Electric Field Center Analysis: 6-Wire High-Voltage Transmission Line</h1>
        
        <div class="canvas-container">
            <div class="simulation-panel">
                <div class="panel-title">Central Field Vector</div>
                <canvas id="fieldCanvas" width="600" height="700"></canvas>
            </div>
            <div class="plot-panel">
                <div class="panel-title">Field Magnitude vs Distance from Center</div>
                <canvas id="plotCanvas" width="600" height="600"></canvas>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h4>Animation Control</h4>
                <button id="playPauseBtn">Pause</button>
                <button id="resetBtn">Reset</button>
                <div class="parameter">
                    <label>Visual Update Rate (Hz):</label>
                    <input type="range" id="updateRateSlider" min="5" max="60" value="30" step="5">
                    <span class="value-display" id="updateRateValue">30</span>
                </div>
            </div>
            
            <div class="control-group">
                <h4>Circuit Control</h4>
                <button id="circuit1Btn" class="circuit-btn">Circuit 1: ON</button>
                <button id="circuit2Btn" class="circuit-btn">Circuit 2: ON</button>
                <div class="parameter">
                    <label>Phase Offset (deg):</label>
                    <input type="range" id="phaseOffsetSlider" min="0" max="360" value="180" step="15">
                    <span class="value-display" id="phaseOffsetValue">180</span>
                </div>
            </div>
            
            <div class="control-group">
                <h4>Electrical Parameters</h4>
                <div class="parameter">
                    <label>Peak Voltage (kV):</label>
                    <input type="range" id="voltageSlider" min="115" max="765" value="345" step="10">
                    <span class="value-display" id="voltageValue">345</span>
                </div>
                <div class="parameter">
                    <label>Frequency (Hz):</label>
                    <input type="range" id="frequencySlider" min="50" max="60" value="60" step="1">
                    <span class="value-display" id="frequencyValue">60</span>
                </div>
            </div>
            
            <div class="control-group">
                <h4>Visualization</h4>
                <div class="parameter">
                    <label>Arrow Scale:</label>
                    <input type="range" id="arrowScaleSlider" min="0.5" max="5" value="2" step="0.1">
                    <span class="value-display" id="arrowScaleValue">2</span>
                </div>
                <div class="parameter">
                    <label>Plot Range Start (m):</label>
                    <input type="range" id="plotStartSlider" min="0" max="20" value="0" step="1">
                    <span class="value-display" id="plotStartValue">0</span>
                </div>
                <div class="parameter">
                    <label>Plot Range End (m):</label>
                    <input type="range" id="plotEndSlider" min="40" max="100" value="50" step="2">
                    <span class="value-display" id="plotEndValue">50</span>
                </div>
                <div class="parameter">
                    <label>Plot Max Field (kV/m):</label>
                    <input type="range" id="plotMaxFieldSlider" min="5" max="50" value="20" step="1">
                    <span class="value-display" id="plotMaxFieldValue">20</span>
                </div>
            </div>
        </div>
        
        <div class="info">
            <h3>Technical Details</h3>
            <p><strong>Configuration:</strong> Double-circuit three-phase transmission line with opposing phase arrangement</p>
            <p><strong>Analysis Focus:</strong> Electric field behavior at center point (0, 29m height)</p>
            <p><strong>Distance Plot:</strong> Field magnitude from center to 12m-58m radius (2×conductor distance to 2×ground distance)</p>
            <p><strong>Mathematical Model:</strong></p>
            <div class="formula">
                E(r,t) = Σᵢ₌₁⁶ [λᵢ(t) / (2πε₀)] · (r̂ᵢ / rᵢ) + E_images(r,t)
                <br>
                Center cancellation: E₁₂(t) + E₂₁(t) ≈ 0 when φ₂ = φ₁ + 180°
            </div>
            <p><strong>Time:</strong> <span id="timeDisplay">0.000</span> s | 
               <strong>Center Field:</strong> <span id="centerField">0.0</span> kV/m |
               <strong>Center Direction:</strong> <span id="centerAngle">0</span>° |
               <strong>Circuit 2 Offset:</strong> <span id="circuit2Phase">180</span>°
            </p>
        </div>
    </div>

    <script>
        // Physical constants
        const EPSILON_0 = 8.854e-12; // F/m
        const TWO_PI = 2 * Math.PI;
        
        // Canvas setup
        const fieldCanvas = document.getElementById('fieldCanvas');
        const plotCanvas = document.getElementById('plotCanvas');
        const fieldCtx = fieldCanvas.getContext('2d');
        const plotCtx = plotCanvas.getContext('2d');
        
        const fieldWidth = fieldCanvas.width;
        const fieldHeight = fieldCanvas.height;
        const plotWidth = plotCanvas.width;
        const plotHeight = plotCanvas.height;
        
        // Coordinate system for field canvas
        const groundLevel = fieldHeight - 80;
        const towerBase = fieldWidth / 2;
        const towerHeight = 35; // meters
        const pixelsPerMeter = 16;
        
        // Animation state
        let animationId;
        let isPaused = false;
        let time = 0;
        let lastUpdateTime = 0;
        let updateRate = 30;
        let updateInterval = 1000 / updateRate;
        let startTime = performance.now();
        const timeScale = 0.05;
        
        // Circuit states
        let circuit1Active = true;
        let circuit2Active = true;
        let phaseOffsetDegrees = 180;
        
        // Electrical parameters
        let peakVoltage = 345000; // Volts
        let frequency = 60; // Hz
        let omega = TWO_PI * frequency;
        
        // Visualization parameters
        let arrowScale = 2;
        let plotStartDistance = 0; // meters
        let plotEndDistance = 50; // meters
        let plotMaxField = 20; // kV/m - fixed Y-axis maximum
        
        // Plot data storage
        let plotData = [];
        const maxPlotPoints = 200;
        
        // Calculate conductor positions (hexagonal with opposite phases)
        function calculateConductorPositions() {
            const hexRadius = 6; // meters
            const centerHeight = towerHeight - 6; // meters from ground
            
            const positions = [];
            
            // Circuit 1: A1, B1, C1 at vertices 0, 2, 4 (every other vertex)
            // Circuit 2: A2, B2, C2 at vertices 3, 5, 1 (opposite to Circuit 1)
            const phaseNames = ['A', 'B', 'C'];
            const circuit1Vertices = [0, 2, 4]; // Top, bottom-right, bottom-left
            const circuit2Vertices = [3, 5, 1]; // Bottom, top-left, top-right (opposite)
            
            // Circuit 1 conductors
            for (let i = 0; i < 3; i++) {
                const vertex = circuit1Vertices[i];
                const angle = (vertex * 60 - 90) * Math.PI / 180; // Start from top
                
                positions.push({
                    x: Math.cos(angle) * hexRadius,
                    y: centerHeight + Math.sin(angle) * hexRadius,
                    phase: i * 120, // 0°, 120°, 240°
                    circuit: 1,
                    label: phaseNames[i] + '1'
                });
            }
            
            // Circuit 2 conductors (opposite positions)
            for (let i = 0; i < 3; i++) {
                const vertex = circuit2Vertices[i];
                const angle = (vertex * 60 - 90) * Math.PI / 180; // Start from top
                
                positions.push({
                    x: Math.cos(angle) * hexRadius,
                    y: centerHeight + Math.sin(angle) * hexRadius,
                    phase: i * 120, // 0°, 120°, 240°
                    circuit: 2,
                    label: phaseNames[i] + '2'
                });
            }
            
            return positions;
        }
        
        const conductors = calculateConductorPositions();
        
        // Convert world coordinates to screen coordinates
        function worldToScreen(x, y) {
            return {
                x: towerBase + x * pixelsPerMeter,
                y: groundLevel - y * pixelsPerMeter
            };
        }
        
        // Calculate electric field using method of images with improved physics accuracy
        function calculateElectricField(worldX, worldY, t) {
            let Ex = 0, Ey = 0;
            
            // Return zero field if point is underground
            if (worldY < 0) {
                return { x: 0, y: 0 };
            }
            
            conductors.forEach((conductor, index) => {
                // Check if circuit is active
                if ((conductor.circuit === 1 && !circuit1Active) || 
                    (conductor.circuit === 2 && !circuit2Active)) {
                    return;
                }
                
                // Distance from point to conductor
                const dx = worldX - conductor.x;
                const dy = worldY - conductor.y;
                const r2 = dx * dx + dy * dy;
                
                // Avoid singularity near conductor
                if (r2 < 0.01) return; // 0.1m minimum distance
                
                const r = Math.sqrt(r2);
                
                // Calculate instantaneous voltage
                const phaseRad = (conductor.phase + (conductor.circuit === 2 ? phaseOffsetDegrees : 0)) * Math.PI / 180;
                const voltage = peakVoltage * Math.sin(omega * t + phaseRad);
                
                // Improved line charge density calculation for transmission lines
                const conductorRadius = 0.015; // 1.5cm typical for high voltage conductors
                const capacitanceCoeff = Math.log(2 * conductor.y / conductorRadius);
                const lambda = 2 * Math.PI * EPSILON_0 * voltage / capacitanceCoeff;
                
                // Electric field from real conductor
                if (r > 0.1) { // Only calculate if far enough from conductor
                    const Er = lambda / (2 * Math.PI * EPSILON_0 * r);
                    const fieldContribX = Er * dx / r / 1000; // Convert to kV/m
                    const fieldContribY = Er * dy / r / 1000;
                    
                    // Apply distance-based attenuation to improve numerical stability
                    const attenuation = Math.min(1.0, 100.0 / r2); // Gentle attenuation at very large distances
                    Ex += fieldContribX * attenuation;
                    Ey += fieldContribY * attenuation;
                }
                
                // Image conductor (ground reflection) - perfect conductor boundary condition
                const dyImage = worldY + conductor.y; // Image conductor position
                const r2Image = dx * dx + dyImage * dyImage;
                
                if (r2Image > 0.01 && dyImage > 0) { // Ensure image is below ground
                    const rImage = Math.sqrt(r2Image);
                    
                    if (rImage > 0.1) { // Only calculate if far enough from image
                        // Image conductor has opposite charge
                        const ErImage = -lambda / (2 * Math.PI * EPSILON_0 * rImage);
                        const imageContribX = ErImage * dx / rImage / 1000;
                        const imageContribY = ErImage * dyImage / rImage / 1000;
                        
                        // Apply distance-based attenuation
                        const attenuationImage = Math.min(1.0, 100.0 / r2Image);
                        Ex += imageContribX * attenuationImage;
                        Ey += imageContribY * attenuationImage;
                    }
                }
            });
            
            // Additional validation - limit unrealistic field values
            const fieldMagnitude = Math.sqrt(Ex * Ex + Ey * Ey);
            if (fieldMagnitude > 200) { // Limit to 200 kV/m maximum
                const scale = 200 / fieldMagnitude;
                Ex *= scale;
                Ey *= scale;
            }
            
            return { x: Ex, y: Ey };
        }
        
        // Get field magnitude
        function getFieldMagnitude(Ex, Ey) {
            return Math.sqrt(Ex * Ex + Ey * Ey);
        }
        
        // Sample field at specific distance from center
        function sampleFieldAtDistance(distance, t) {
            const centerHeight = towerHeight - 6;
            
            // Special case: distance = 0 means sample at exact center point
            if (distance === 0) {
                const field = calculateElectricField(0, centerHeight, t);
                return getFieldMagnitude(field.x, field.y);
            }
            
            // For distance > 0, sample around circle and average
            const numSamples = 8; // Sample at 8 points around circle
            let totalMag = 0;
            
            for (let i = 0; i < numSamples; i++) {
                const angle = (i / numSamples) * TWO_PI;
                const x = Math.cos(angle) * distance;
                const y = centerHeight + Math.sin(angle) * distance;
                
                const field = calculateElectricField(x, y, t);
                const magnitude = getFieldMagnitude(field.x, field.y);
                totalMag += magnitude;
            }
            
            return totalMag / numSamples; // Average magnitude
        }
        
        // Draw transmission tower
        function drawTower() {
            const base = worldToScreen(0, 0);
            const top = worldToScreen(0, towerHeight);
            
            fieldCtx.strokeStyle = '#444';
            fieldCtx.lineWidth = 4;
            
            // Main vertical structure
            fieldCtx.beginPath();
            fieldCtx.moveTo(base.x - 30, base.y);
            fieldCtx.lineTo(top.x - 10, top.y);
            fieldCtx.moveTo(base.x + 30, base.y);
            fieldCtx.lineTo(top.x + 10, top.y);
            fieldCtx.stroke();
            
            // Cross braces
            fieldCtx.lineWidth = 2;
            fieldCtx.strokeStyle = '#555';
            const braceCount = 4;
            for (let i = 1; i <= braceCount; i++) {
                const y = i * towerHeight / (braceCount + 1);
                const width_at_y = 30 - (20 * i / (braceCount + 1));
                const p1 = worldToScreen(-width_at_y/pixelsPerMeter, y);
                const p2 = worldToScreen(width_at_y/pixelsPerMeter, y);
                
                fieldCtx.beginPath();
                fieldCtx.moveTo(p1.x, p1.y);
                fieldCtx.lineTo(p2.x, p2.y);
                fieldCtx.stroke();
            }
            
            // Hexagonal support structure
            const armY = towerHeight - 6;
            const armPos = worldToScreen(0, armY);
            fieldCtx.lineWidth = 3;
            fieldCtx.strokeStyle = '#444';
            
            const hexRadius = 6;
            for (let i = 0; i < 6; i++) {
                const angle = (i * 60 - 90) * Math.PI / 180;
                const endX = Math.cos(angle) * hexRadius * 0.8;
                const endY = armY + Math.sin(angle) * hexRadius * 0.8;
                const end = worldToScreen(endX, endY);
                
                fieldCtx.beginPath();
                fieldCtx.moveTo(armPos.x, armPos.y);
                fieldCtx.lineTo(end.x, end.y);
                fieldCtx.stroke();
            }
        }
        
        // Draw ground
        function drawGround() {
            fieldCtx.fillStyle = '#8B7355';
            fieldCtx.fillRect(0, groundLevel, fieldWidth, fieldHeight - groundLevel);
            
            fieldCtx.fillStyle = '#228B22';
            fieldCtx.fillRect(0, groundLevel, fieldWidth, 5);
        }
        
        // Draw conductors
        function drawConductors() {
            conductors.forEach(conductor => {
                const pos = worldToScreen(conductor.x, conductor.y);
                
                const isActive = (conductor.circuit === 1 && circuit1Active) || 
                               (conductor.circuit === 2 && circuit2Active);
                
                fieldCtx.beginPath();
                fieldCtx.arc(pos.x, pos.y, 6, 0, TWO_PI);
                
                if (isActive) {
                    const phaseRad = (conductor.phase + (conductor.circuit === 2 ? phaseOffsetDegrees : 0)) * Math.PI / 180;
                    const voltage = Math.sin(omega * time + phaseRad);
                    const intensity = (voltage + 1) / 2;
                    
                    fieldCtx.fillStyle = `rgb(${255 * intensity}, ${100 * intensity}, ${100 * intensity})`;
                } else {
                    fieldCtx.fillStyle = '#444';
                }
                
                fieldCtx.fill();
                fieldCtx.strokeStyle = isActive ? '#fff' : '#666';
                fieldCtx.lineWidth = 2;
                fieldCtx.stroke();
                
                fieldCtx.fillStyle = isActive ? '#fff' : '#666';
                fieldCtx.font = 'bold 10px Arial';
                fieldCtx.textAlign = 'center';
                fieldCtx.textBaseline = 'middle';
                fieldCtx.fillText(conductor.label, pos.x, pos.y);
            });
        }
        
        // Draw central arrow
        function drawCentralArrow() {
            const centerHeight = towerHeight - 6;
            const centerPos = worldToScreen(0, centerHeight);
            
            // Calculate center field
            const centerField = calculateElectricField(0, centerHeight, time);
            const centerFieldMag = getFieldMagnitude(centerField.x, centerField.y);
            
            if (centerFieldMag > 0.01) {
                // Arrow properties
                const maxArrowLength = 100;
                const arrowLength = Math.min(centerFieldMag * arrowScale * 10, maxArrowLength);
                const arrowAngle = Math.atan2(-centerField.y, centerField.x); // Negative y for screen coords
                
                // Arrow shaft
                const endX = centerPos.x + Math.cos(arrowAngle) * arrowLength;
                const endY = centerPos.y + Math.sin(arrowAngle) * arrowLength;
                
                fieldCtx.strokeStyle = '#FF0000';
                fieldCtx.lineWidth = 6;
                fieldCtx.beginPath();
                fieldCtx.moveTo(centerPos.x, centerPos.y);
                fieldCtx.lineTo(endX, endY);
                fieldCtx.stroke();
                
                // Arrow head
                const headLength = 15;
                const headAngle = 0.5;
                
                fieldCtx.beginPath();
                fieldCtx.moveTo(endX, endY);
                fieldCtx.lineTo(
                    endX - headLength * Math.cos(arrowAngle - headAngle),
                    endY - headLength * Math.sin(arrowAngle - headAngle)
                );
                fieldCtx.moveTo(endX, endY);
                fieldCtx.lineTo(
                    endX - headLength * Math.cos(arrowAngle + headAngle),
                    endY - headLength * Math.sin(arrowAngle + headAngle)
                );
                fieldCtx.stroke();
            }
            
            // Update center field display
            document.getElementById('centerField').textContent = centerFieldMag.toFixed(2);
            const centerAngle = Math.atan2(-centerField.y, centerField.x) * 180 / Math.PI;
            document.getElementById('centerAngle').textContent = centerAngle.toFixed(1);
        }
        
        // Draw distance scale/grid
        function drawDistanceScale() {
            const centerHeight = towerHeight - 6;
            const centerPos = worldToScreen(0, centerHeight);
            
            // Draw concentric circles at 10m, 20m, 30m, 40m, 50m intervals
            fieldCtx.strokeStyle = '#CCCCCC';
            fieldCtx.lineWidth = 1;
            fieldCtx.setLineDash([5, 5]); // Dashed lines
            
            for (let distance = 10; distance <= 50; distance += 10) {
                const radius = distance * pixelsPerMeter;
                
                fieldCtx.beginPath();
                fieldCtx.arc(centerPos.x, centerPos.y, radius, 0, TWO_PI);
                fieldCtx.stroke();
                
                // Add distance labels at the right side of each circle
                const labelX = centerPos.x + radius;
                const labelY = centerPos.y;
                
                // Only draw label if it's within canvas bounds
                if (labelX < fieldWidth - 20) {
                    fieldCtx.fillStyle = '#666666';
                    fieldCtx.font = '12px Arial';
                    fieldCtx.textAlign = 'left';
                    fieldCtx.textBaseline = 'middle';
                    fieldCtx.fillText(`${distance}m`, labelX + 5, labelY);
                }
            }
            
            // Reset line dash
            fieldCtx.setLineDash([]);
            
            // Draw horizontal and vertical reference lines through center
            fieldCtx.strokeStyle = '#BBBBBB';
            fieldCtx.lineWidth = 1;
            fieldCtx.setLineDash([3, 3]);
            
            // Horizontal line
            fieldCtx.beginPath();
            fieldCtx.moveTo(0, centerPos.y);
            fieldCtx.lineTo(fieldWidth, centerPos.y);
            fieldCtx.stroke();
            
            // Vertical line
            fieldCtx.beginPath();
            fieldCtx.moveTo(centerPos.x, 0);
            fieldCtx.lineTo(centerPos.x, fieldHeight);
            fieldCtx.stroke();
            
            // Reset line dash
            fieldCtx.setLineDash([]);
        }
        
        // Draw secondary E-vector at 25m from center
        function drawSecondaryArrow() {
            const centerHeight = towerHeight - 6;
            const distance = 25; // 25m from center
            const angle = 0; // To the right of center (can be made configurable later)
            
            const vectorX = Math.cos(angle) * distance;
            const vectorY = centerHeight;
            const vectorPos = worldToScreen(vectorX, vectorY);
            
            // Calculate field at this position
            const field = calculateElectricField(vectorX, vectorY, time);
            const fieldMag = getFieldMagnitude(field.x, field.y);
            
            if (fieldMag > 0.01) {
                // Arrow properties
                const maxArrowLength = 60;
                const arrowLength = Math.min(fieldMag * arrowScale * 5, maxArrowLength);
                const arrowAngle = Math.atan2(-field.y, field.x); // Negative y for screen coords
                
                // Arrow shaft
                const endX = vectorPos.x + Math.cos(arrowAngle) * arrowLength;
                const endY = vectorPos.y + Math.sin(arrowAngle) * arrowLength;
                
                fieldCtx.strokeStyle = '#0066FF'; // Blue color to distinguish from center arrow
                fieldCtx.lineWidth = 4;
                fieldCtx.beginPath();
                fieldCtx.moveTo(vectorPos.x, vectorPos.y);
                fieldCtx.lineTo(endX, endY);
                fieldCtx.stroke();
                
                // Arrow head
                const headLength = 12;
                const headAngle = 0.5;
                
                fieldCtx.beginPath();
                fieldCtx.moveTo(endX, endY);
                fieldCtx.lineTo(
                    endX - headLength * Math.cos(arrowAngle - headAngle),
                    endY - headLength * Math.sin(arrowAngle - headAngle)
                );
                fieldCtx.moveTo(endX, endY);
                fieldCtx.lineTo(
                    endX - headLength * Math.cos(arrowAngle + headAngle),
                    endY - headLength * Math.sin(arrowAngle + headAngle)
                );
                fieldCtx.stroke();
            }
            
            // Draw position marker
            fieldCtx.beginPath();
            fieldCtx.arc(vectorPos.x, vectorPos.y, 4, 0, TWO_PI);
            fieldCtx.fillStyle = '#0066FF';
            fieldCtx.fill();
            fieldCtx.strokeStyle = '#FFFFFF';
            fieldCtx.lineWidth = 2;
            fieldCtx.stroke();
            
            // Add label - compare single point vs averaged value
            const averagedFieldMag = sampleFieldAtDistance(25, time);
            fieldCtx.fillStyle = '#0066FF';
            fieldCtx.font = 'bold 12px Arial';
            fieldCtx.textAlign = 'center';
            fieldCtx.textBaseline = 'bottom';
            fieldCtx.fillText(`25m: ${fieldMag.toFixed(1)} kV/m (avg: ${averagedFieldMag.toFixed(1)})`, vectorPos.x, vectorPos.y - 10);
        }
        
        // Draw field magnitude plot
        function drawFieldPlot() {
            const centerHeight = towerHeight - 6;
            
            // Clear plot canvas
            plotCtx.clearRect(0, 0, plotWidth, plotHeight);
            
            // Plot margins
            const margin = 60;
            const plotAreaWidth = plotWidth - 2 * margin;
            const plotAreaHeight = plotHeight - 2 * margin;
            
            // Sample field at different distances
            const distances = [];
            const magnitudes = [];
            const numSamples = 50;
            
            for (let i = 0; i < numSamples; i++) {
                const distance = plotStartDistance + (plotEndDistance - plotStartDistance) * i / (numSamples - 1);
                const magnitude = sampleFieldAtDistance(distance, time);
                distances.push(distance);
                magnitudes.push(magnitude);
            }
            
            // Use fixed Y-axis scaling instead of auto-scaling
            const maxMag = plotMaxField;
            
            // Draw axes
            plotCtx.strokeStyle = '#333';
            plotCtx.lineWidth = 2;
            plotCtx.beginPath();
            // X-axis
            plotCtx.moveTo(margin, plotHeight - margin);
            plotCtx.lineTo(plotWidth - margin, plotHeight - margin);
            // Y-axis
            plotCtx.moveTo(margin, margin);
            plotCtx.lineTo(margin, plotHeight - margin);
            plotCtx.stroke();
            
            // Draw grid
            plotCtx.strokeStyle = '#ddd';
            plotCtx.lineWidth = 1;
            
            // Vertical grid lines - match 10m intervals
            for (let i = 0; i <= 5; i++) {
                const distance = i * 10;
                const x = margin + (plotAreaWidth * distance / (plotEndDistance - plotStartDistance));
                plotCtx.beginPath();
                plotCtx.moveTo(x, margin);
                plotCtx.lineTo(x, plotHeight - margin);
                plotCtx.stroke();
            }
            
            // Horizontal grid lines
            for (let i = 0; i <= 10; i++) {
                const y = margin + (plotAreaHeight * i / 10);
                plotCtx.beginPath();
                plotCtx.moveTo(margin, y);
                plotCtx.lineTo(plotWidth - margin, y);
                plotCtx.stroke();
            }
            
            // Draw field magnitude curve
            plotCtx.strokeStyle = '#0066CC';
            plotCtx.lineWidth = 3;
            plotCtx.beginPath();
            
            for (let i = 0; i < distances.length; i++) {
                const x = margin + (distances[i] - plotStartDistance) / (plotEndDistance - plotStartDistance) * plotAreaWidth;
                const y = plotHeight - margin - (magnitudes[i] / maxMag) * plotAreaHeight;
                
                if (i === 0) {
                    plotCtx.moveTo(x, y);
                } else {
                    plotCtx.lineTo(x, y);
                }
            }
            plotCtx.stroke();
            
            // Draw labels
            plotCtx.fillStyle = '#333';
            plotCtx.font = '12px Arial';
            plotCtx.textAlign = 'center';
            
            // X-axis labels - use 10m intervals
            for (let i = 0; i <= 5; i++) {
                const distance = i * 10; // 0, 10, 20, 30, 40, 50m
                const x = margin + (plotAreaWidth * distance / (plotEndDistance - plotStartDistance));
                plotCtx.fillText(distance + 'm', x, plotHeight - margin + 20);
            }
            
            // Y-axis labels
            plotCtx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const magnitude = (maxMag * i / 5);
                const y = plotHeight - margin - (plotAreaHeight * i / 5);
                plotCtx.fillText(magnitude.toFixed(1), margin - 10, y + 4);
            }
            
            // Axis titles
            plotCtx.textAlign = 'center';
            plotCtx.font = '14px Arial';
            plotCtx.fillText('Distance from Center (m)', plotWidth / 2, plotHeight - 20);
            
            plotCtx.save();
            plotCtx.translate(20, plotHeight / 2);
            plotCtx.rotate(-Math.PI / 2);
            plotCtx.fillText('Field Magnitude (kV/m)', 0, 0);
            plotCtx.restore();
            
            // Title
            plotCtx.textAlign = 'center';
            plotCtx.font = 'bold 16px Arial';
            plotCtx.fillText('Electric Field vs Distance', plotWidth / 2, 30);
            
            // Mark conductor position at 6m
            const conductor6mX = margin + (6 / (plotEndDistance - plotStartDistance)) * plotAreaWidth;
            plotCtx.strokeStyle = '#FF6600';
            plotCtx.lineWidth = 2;
            plotCtx.setLineDash([4, 4]);
            plotCtx.beginPath();
            plotCtx.moveTo(conductor6mX, margin);
            plotCtx.lineTo(conductor6mX, plotHeight - margin);
            plotCtx.stroke();
            plotCtx.setLineDash([]);
            
            // Label for conductor position
            plotCtx.fillStyle = '#FF6600';
            plotCtx.font = '10px Arial';
            plotCtx.textAlign = 'left';
            plotCtx.fillText('Conductors', conductor6mX + 2, margin + 15);
        }
        
        // Main render function
        function render() {
            // Clear and draw field canvas
            const gradient = fieldCtx.createLinearGradient(0, 0, 0, fieldHeight);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.7, '#E0F6FF');
            gradient.addColorStop(1, '#C8D6C8');
            fieldCtx.fillStyle = gradient;
            fieldCtx.fillRect(0, 0, fieldWidth, fieldHeight);
            
            drawGround();
            drawDistanceScale();
            drawTower();
            drawConductors();
            drawCentralArrow();
            drawSecondaryArrow();
            
            // Draw plot
            drawFieldPlot();
            
            // Update time display
            document.getElementById('timeDisplay').textContent = time.toFixed(3);
            document.getElementById('circuit2Phase').textContent = phaseOffsetDegrees.toFixed(0);
        }
        
        // Animation loop
        function animate(currentTime) {
            if (!isPaused) {
                if (currentTime - lastUpdateTime >= updateInterval) {
                    const elapsedSeconds = (currentTime - startTime) / 1000;
                    time = elapsedSeconds * timeScale;
                    
                    lastUpdateTime = currentTime;
                    render();
                }
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Event handlers
        document.getElementById('playPauseBtn').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'Play' : 'Pause';
            
            if (!isPaused) {
                const pausedDuration = performance.now() - lastUpdateTime;
                startTime += pausedDuration;
                lastUpdateTime = performance.now();
            }
        });
        
        document.getElementById('resetBtn').addEventListener('click', function() {
            time = 0;
            startTime = performance.now();
            lastUpdateTime = 0;
            render();
        });
        
        document.getElementById('circuit1Btn').addEventListener('click', function() {
            circuit1Active = !circuit1Active;
            this.textContent = `Circuit 1: ${circuit1Active ? 'ON' : 'OFF'}`;
            this.classList.toggle('off', !circuit1Active);
            render();
        });
        
        document.getElementById('circuit2Btn').addEventListener('click', function() {
            circuit2Active = !circuit2Active;
            this.textContent = `Circuit 2: ${circuit2Active ? 'ON' : 'OFF'}`;
            this.classList.toggle('off', !circuit2Active);
            render();
        });
        
        document.getElementById('updateRateSlider').addEventListener('input', function() {
            updateRate = parseInt(this.value);
            updateInterval = 1000 / updateRate;
            document.getElementById('updateRateValue').textContent = this.value;
        });
        
        document.getElementById('phaseOffsetSlider').addEventListener('input', function() {
            phaseOffsetDegrees = parseInt(this.value);
            document.getElementById('phaseOffsetValue').textContent = this.value;
            render();
        });
        
        document.getElementById('voltageSlider').addEventListener('input', function() {
            peakVoltage = parseInt(this.value) * 1000;
            document.getElementById('voltageValue').textContent = this.value;
            render();
        });
        
        document.getElementById('frequencySlider').addEventListener('input', function() {
            frequency = parseInt(this.value);
            omega = TWO_PI * frequency;
            document.getElementById('frequencyValue').textContent = this.value;
        });
        
        document.getElementById('arrowScaleSlider').addEventListener('input', function() {
            arrowScale = parseFloat(this.value);
            document.getElementById('arrowScaleValue').textContent = this.value;
            render();
        });
        
        document.getElementById('plotStartSlider').addEventListener('input', function() {
            plotStartDistance = parseInt(this.value);
            document.getElementById('plotStartValue').textContent = this.value;
            render();
        });
        
        document.getElementById('plotEndSlider').addEventListener('input', function() {
            plotEndDistance = parseInt(this.value);
            document.getElementById('plotEndValue').textContent = this.value;
            render();
        });
        
        document.getElementById('plotMaxFieldSlider').addEventListener('input', function() {
            plotMaxField = parseInt(this.value);
            document.getElementById('plotMaxFieldValue').textContent = this.value;
            render();
        });
        
        // Initial render and start animation
        render();
        animate(performance.now());
    </script>
</body>
</html>