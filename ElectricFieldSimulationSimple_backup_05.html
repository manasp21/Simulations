<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electric Field Center Analysis - 6-Wire Transmission Line</title>
    
    <!-- MathJax for LaTeX mathematical expressions -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .canvas-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .simulation-panel {
            flex: 1;
        }
        .plot-panel {
            flex: 1;
        }
        canvas {
            border: 1px solid #333;
            display: block;
            margin: 0 auto;
        }
        #fieldCanvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 70%, #C8D6C8 100%);
        }
        #plotCanvas {
            background: white;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .control-group {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .control-group h4 {
            margin-top: 0;
            color: #333;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button.off {
            background-color: #f44336;
        }
        button.off:hover {
            background-color: #da190b;
        }
        .parameter {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 180px;
            font-weight: bold;
        }
        input[type="range"] {
            width: 200px;
            vertical-align: middle;
        }
        .value-display {
            display: inline-block;
            width: 60px;
            text-align: right;
            font-family: monospace;
        }
        .info {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            font-size: 14px;
        }
        .formula {
            font-family: 'Courier New', monospace;
            background-color: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
            overflow-x: auto;
        }
        .panel-title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Electric Field Center Analysis: 6-Wire High-Voltage Transmission Line</h1>
        
        <div class="canvas-container">
            <div class="simulation-panel">
                <div class="panel-title">Central Field Vector</div>
                <canvas id="fieldCanvas" width="600" height="800"></canvas>
            </div>
            <div class="plot-panel">
                <div class="panel-title">Field Magnitude vs Distance from Center</div>
                <canvas id="plotCanvas" width="600" height="600"></canvas>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h4>Animation Control</h4>
                <button id="playPauseBtn">Pause</button>
                <button id="resetBtn">Reset</button>
            </div>
            
            <div class="control-group">
                <h4>Circuit Control</h4>
                <button id="circuit1Btn" class="circuit-btn">Circuit 1: ON</button>
                <button id="circuit2Btn" class="circuit-btn">Circuit 2: ON</button>
                <div class="parameter">
                    <label>Phase Offset (deg):</label>
                    <input type="range" id="phaseOffsetSlider" min="0" max="360" value="0" step="15">
                    <span class="value-display" id="phaseOffsetValue">0</span>
                </div>
            </div>
            
            <div class="control-group">
                <h4>Electrical Parameters</h4>
                <div class="parameter">
                    <label>Frequency (Hz):</label>
                    <input type="range" id="frequencySlider" min="0" max="60" value="60" step="1">
                    <span class="value-display" id="frequencyValue">60</span>
                </div>
            </div>
            
            <div class="control-group">
                <h4>Visualization</h4>
                <div class="parameter">
                    <label>Plot Range Start (m):</label>
                    <input type="range" id="plotStartSlider" min="0" max="20" value="0" step="1">
                    <span class="value-display" id="plotStartValue">0</span>
                </div>
                <div class="parameter">
                    <label>Plot Range End (m):</label>
                    <input type="range" id="plotEndSlider" min="40" max="100" value="50" step="2">
                    <span class="value-display" id="plotEndValue">50</span>
                </div>
                <div class="parameter">
                    <label>Plot Max Field (kV/m):</label>
                    <input type="range" id="plotMaxFieldSlider" min="0.1" max="5" value="2" step="0.1">
                    <span class="value-display" id="plotMaxFieldValue">2</span>
                </div>
            </div>
        </div>
        
        <div class="info">
            <h3>Technical Details</h3>
            <p><strong>Configuration:</strong> Double-circuit three-phase transmission line with opposing phase arrangement</p>
            <p><strong>Analysis Focus:</strong> Electric field behavior at center point (0, 44m height)</p>
            <p><strong>Distance Plot:</strong> Ultra-high resolution field magnitude from center to 50m radius</p>
            <p><strong>Vector Analysis:</strong> Center (red), 25m (blue), and ground-level 40m (green) field vectors</p>
            <p><strong>Mathematical Model:</strong></p>
            <div class="formula">
                E(r,t) = Σᵢ₌₁⁶ [λᵢ(t) / (2πε₀)] · (r̂ᵢ / rᵢ) [Conducting cylinders, Non-conducting ground]
                <br>
                λᵢ(t) = 2πε₀Vᵢ(t) / ln(2hᵢ/a) | E = 0 inside conductors | No ground images
                <br>
                Center cancellation: E₁₂(t) + E₂₁(t) ≈ 0 when φ₂ = φ₁ + 180°
            </div>
            <p><strong>Time:</strong> <span id="timeDisplay">0.000</span> s | 
               <strong>Center Field:</strong> <span id="centerField">0.0</span> kV/m |
               <strong>Center Direction:</strong> <span id="centerAngle">0</span>° |
               <strong>Circuit 2 Offset:</strong> <span id="circuit2Phase">0</span>°
            </p>
        </div>
    </div>

    <script>
        // Physical constants
        const EPSILON_0 = 8.854e-12; // F/m
        const TWO_PI = 2 * Math.PI;
        
        // Canvas setup
        const fieldCanvas = document.getElementById('fieldCanvas');
        const plotCanvas = document.getElementById('plotCanvas');
        const fieldCtx = fieldCanvas.getContext('2d');
        const plotCtx = plotCanvas.getContext('2d');
        
        const fieldWidth = fieldCanvas.width;
        const fieldHeight = fieldCanvas.height;
        const plotWidth = plotCanvas.width;
        const plotHeight = plotCanvas.height;
        
        // Coordinate system for field canvas
        const groundLevel = fieldHeight - 80;
        const towerBase = fieldWidth / 3; // Shift tower left to make right-side vectors visible
        const towerHeight = 50; // meters
        const pixelsPerMeter = 12; // Reduced scaling to fit 50m tower
        
        // Animation state
        let animationId;
        let isPaused = false;
        let time = 0;
        let lastUpdateTime = 0;
        let updateRate = 30;
        let updateInterval = 1000 / updateRate;
        let startTime = 0; // Will be initialized on first animation frame
        const timeScale = 0.01; // Slow, smooth vector movement
        
        // Circuit states
        let circuit1Active = true;
        let circuit2Active = true;
        let phaseOffsetDegrees = 0;
        
        // Electrical parameters
        let peakVoltage = 30000; // Volts (Fixed at 30 kV)
        let frequency = 60; // Hz
        let omega = TWO_PI * frequency;
        
        // Visualization parameters
        let arrowScale = 2;
        let plotStartDistance = 0; // meters
        let plotEndDistance = 50; // meters
        let plotMaxField = 2; // kV/m - default field range for general analysis
        
        // Plot data storage
        let plotData = [];
        const maxPlotPoints = 200;
        
        // Calculate conductor positions (hexagonal with opposite phases)
        function calculateConductorPositions() {
            const hexRadius = 9; // meters - increased for better label visibility
            const centerHeight = towerHeight - 6; // meters from ground
            
            const positions = [];
            
            // Circuit 1: A1, B1, C1 at vertices 0, 2, 4 (every other vertex)
            // Circuit 2: A2, B2, C2 at vertices 3, 5, 1 (opposite to Circuit 1)
            const phaseNames = ['A', 'B', 'C'];
            const circuit1Vertices = [0, 2, 4]; // Top, bottom-right, bottom-left
            const circuit2Vertices = [3, 5, 1]; // Bottom, top-left, top-right (opposite)
            
            // Circuit 1 conductors
            for (let i = 0; i < 3; i++) {
                const vertex = circuit1Vertices[i];
                const angle = (vertex * 60 - 90) * Math.PI / 180; // Start from top
                
                positions.push({
                    x: Math.cos(angle) * hexRadius,
                    y: centerHeight + Math.sin(angle) * hexRadius,
                    phase: i * 120, // 0°, 120°, 240°
                    circuit: 1,
                    label: phaseNames[i] + '1'
                });
            }
            
            // Circuit 2 conductors (opposite positions with 180° phase offset)
            for (let i = 0; i < 3; i++) {
                const vertex = circuit2Vertices[i];
                const angle = (vertex * 60 - 90) * Math.PI / 180; // Start from top
                
                positions.push({
                    x: Math.cos(angle) * hexRadius,
                    y: centerHeight + Math.sin(angle) * hexRadius,
                    phase: (i * 120 + 180) % 360, // 180°, 300°, 60° (opposing phase arrangement)
                    circuit: 2,
                    label: phaseNames[i] + '2'
                });
            }
            
            return positions;
        }
        
        const conductors = calculateConductorPositions();
        
        // Convert world coordinates to screen coordinates
        function worldToScreen(x, y) {
            return {
                x: towerBase + x * pixelsPerMeter,
                y: groundLevel - y * pixelsPerMeter
            };
        }
        
        // Calculate electric field: conducting conductors above non-conducting ground
        function calculateElectricField(worldX, worldY, t) {
            let Ex = 0, Ey = 0;
            
            // Return zero field if point is underground
            if (worldY < 0) {
                return { x: 0, y: 0 };
            }
            
            // CONDUCTING BOUNDARY CONDITION: E = 0 inside any conductor
            const conductorRadius = 0.015; // 1.5cm physical conductor radius
            for (let conductor of conductors) {
                const dx = worldX - conductor.x;
                const dy = worldY - conductor.y;
                const distanceToCenter = Math.sqrt(dx * dx + dy * dy);
                
                // Return zero field if inside any conducting cylinder
                if (distanceToCenter <= conductorRadius) {
                    return { x: 0, y: 0 };
                }
            }
            
            conductors.forEach((conductor, index) => {
                // Check if circuit is active
                if ((conductor.circuit === 1 && !circuit1Active) || 
                    (conductor.circuit === 2 && !circuit2Active)) {
                    return;
                }
                
                // Distance from point to conductor
                const dx = worldX - conductor.x;
                const dy = worldY - conductor.y;
                const r2 = dx * dx + dy * dy;
                const r = Math.sqrt(r2);
                
                // Skip if too close to conductor surface (already checked above, but safety margin)
                if (r <= conductorRadius * 1.1) return; // Small safety margin beyond conductor surface
                
                // Calculate instantaneous voltage
                const phaseRad = (conductor.phase + (conductor.circuit === 2 ? phaseOffsetDegrees : 0)) * Math.PI / 180;
                const voltage = peakVoltage * Math.sin(omega * t + phaseRad);
                
                // Line charge density for conducting cylinder at voltage V
                // For cylinder in free space: λ = 2πε₀V / ln(2h/a) where h = height, a = radius
                const capacitanceCoeff = Math.log(2 * conductor.y / conductorRadius);
                const lambda = 2 * Math.PI * EPSILON_0 * voltage / capacitanceCoeff;
                
                // Electric field from conducting cylinder (line charge approximation valid for r >> a)
                const Er = lambda / (2 * Math.PI * EPSILON_0 * r);
                const fieldContribX = Er * dx / r / 1000; // Convert to kV/m
                const fieldContribY = Er * dy / r / 1000;
                
                // Natural 1/r physics from conducting cylinder
                Ex += fieldContribX;
                Ey += fieldContribY;
                
                // Non-conducting ground assumption - no image conductors
            });
            
            // Natural electric field physics - no artificial limitations
            
            return { x: Ex, y: Ey };
        }
        
        // Get field magnitude
        function getFieldMagnitude(Ex, Ey) {
            return Math.sqrt(Ex * Ex + Ey * Ey);
        }
        
        // Sample field at specific distance from center along 45-degree line
        function sampleFieldAtDistance(distance, t) {
            const centerHeight = towerHeight - 6;
            
            // Special case: distance = 0 means sample at exact center point
            if (distance === 0) {
                const field = calculateElectricField(0, centerHeight, t);
                return getFieldMagnitude(field.x, field.y);
            }
            
            // Sample along 315-degree line (southeast direction) to avoid conductors
            const angle = 315 * Math.PI / 180; // 315 degrees
            const x = Math.cos(angle) * distance;
            const y = centerHeight + Math.sin(angle) * distance;
            
            // Safety check for underground points
            if (y <= 0) return 0;
            
            // Single point sampling along the line - no averaging needed
            const field = calculateElectricField(x, y, t);
            return getFieldMagnitude(field.x, field.y);
        }
        
        // Draw transmission tower
        function drawTower() {
            const base = worldToScreen(0, 0);
            const top = worldToScreen(0, towerHeight);
            
            fieldCtx.strokeStyle = '#444';
            fieldCtx.lineWidth = 4;
            
            // Main vertical structure
            fieldCtx.beginPath();
            fieldCtx.moveTo(base.x - 30, base.y);
            fieldCtx.lineTo(top.x - 10, top.y);
            fieldCtx.moveTo(base.x + 30, base.y);
            fieldCtx.lineTo(top.x + 10, top.y);
            fieldCtx.stroke();
            
            // Cross braces
            fieldCtx.lineWidth = 2;
            fieldCtx.strokeStyle = '#555';
            const braceCount = 4;
            for (let i = 1; i <= braceCount; i++) {
                const y = i * towerHeight / (braceCount + 1);
                const width_at_y = 30 - (20 * i / (braceCount + 1));
                const p1 = worldToScreen(-width_at_y/pixelsPerMeter, y);
                const p2 = worldToScreen(width_at_y/pixelsPerMeter, y);
                
                fieldCtx.beginPath();
                fieldCtx.moveTo(p1.x, p1.y);
                fieldCtx.lineTo(p2.x, p2.y);
                fieldCtx.stroke();
            }
            
            // Hexagonal support structure
            const armY = towerHeight - 6;
            const armPos = worldToScreen(0, armY);
            fieldCtx.lineWidth = 3;
            fieldCtx.strokeStyle = '#444';
            
            const hexRadius = 9; // Match conductor spacing
            for (let i = 0; i < 6; i++) {
                const angle = (i * 60 - 90) * Math.PI / 180;
                const endX = Math.cos(angle) * hexRadius * 0.8;
                const endY = armY + Math.sin(angle) * hexRadius * 0.8;
                const end = worldToScreen(endX, endY);
                
                fieldCtx.beginPath();
                fieldCtx.moveTo(armPos.x, armPos.y);
                fieldCtx.lineTo(end.x, end.y);
                fieldCtx.stroke();
            }
        }
        
        // Draw ground
        function drawGround() {
            fieldCtx.fillStyle = '#8B7355';
            fieldCtx.fillRect(0, groundLevel, fieldWidth, fieldHeight - groundLevel);
            
            fieldCtx.fillStyle = '#228B22';
            fieldCtx.fillRect(0, groundLevel, fieldWidth, 5);
            
            // Add "Non-conducting Ground" label
            const centerX = fieldWidth / 2;
            const labelY = groundLevel + 30;
            
            // Label background for better readability
            fieldCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            fieldCtx.fillRect(centerX - 96, labelY - 12, 192, 24);
            fieldCtx.strokeStyle = '#333';
            fieldCtx.lineWidth = 1;
            fieldCtx.strokeRect(centerX - 96, labelY - 12, 192, 24);
            
            // Label text
            fieldCtx.fillStyle = '#333';
            fieldCtx.font = 'bold 16px Arial';
            fieldCtx.textAlign = 'center';
            fieldCtx.textBaseline = 'middle';
            fieldCtx.fillText('Non-conducting Ground', centerX, labelY);
        }
        
        // Draw conductors
        function drawConductors() {
            conductors.forEach(conductor => {
                const pos = worldToScreen(conductor.x, conductor.y);
                
                const isActive = (conductor.circuit === 1 && circuit1Active) || 
                               (conductor.circuit === 2 && circuit2Active);
                
                fieldCtx.beginPath();
                fieldCtx.arc(pos.x, pos.y, 6, 0, TWO_PI);
                
                if (isActive) {
                    const phaseRad = (conductor.phase + (conductor.circuit === 2 ? phaseOffsetDegrees : 0)) * Math.PI / 180;
                    const voltage = Math.sin(omega * time + phaseRad);
                    const intensity = (voltage + 1) / 2;
                    
                    fieldCtx.fillStyle = `rgb(${255 * intensity}, ${100 * intensity}, ${100 * intensity})`;
                } else {
                    fieldCtx.fillStyle = '#444';
                }
                
                fieldCtx.fill();
                fieldCtx.strokeStyle = isActive ? '#fff' : '#666';
                fieldCtx.lineWidth = 2;
                fieldCtx.stroke();
                
                // Draw label outside the conductor circle for visibility
                fieldCtx.fillStyle = isActive ? '#fff' : '#666';
                fieldCtx.font = 'bold 12px Arial';
                fieldCtx.textAlign = 'center';
                fieldCtx.textBaseline = 'middle';
                
                // Position label outside conductor circle (18px offset)
                const labelOffset = 18;
                const labelX = pos.x + labelOffset;
                const labelY = pos.y - labelOffset;
                
                // Add black outline for better visibility
                fieldCtx.strokeStyle = '#000';
                fieldCtx.lineWidth = 3;
                fieldCtx.strokeText(conductor.label, labelX, labelY);
                fieldCtx.fillText(conductor.label, labelX, labelY);
            });
        }
        
        // Draw central arrow
        function drawCentralArrow() {
            const centerHeight = towerHeight - 6;
            const centerPos = worldToScreen(0, centerHeight);
            
            // Calculate center field
            const centerField = calculateElectricField(0, centerHeight, time);
            const centerFieldMag = getFieldMagnitude(centerField.x, centerField.y);
            
            if (centerFieldMag > 0.001) { // Lower threshold for ultra-low field analysis
                // Arrow properties
                const maxArrowLength = 100;
                const arrowLength = Math.min(centerFieldMag * arrowScale * 100, maxArrowLength); // Base scale reference (1x)
                const arrowAngle = Math.atan2(-centerField.y, centerField.x); // Negative y for screen coords
                
                // Arrow shaft
                const endX = centerPos.x + Math.cos(arrowAngle) * arrowLength;
                const endY = centerPos.y + Math.sin(arrowAngle) * arrowLength;
                
                fieldCtx.strokeStyle = '#FF0000';
                fieldCtx.lineWidth = 6;
                fieldCtx.beginPath();
                fieldCtx.moveTo(centerPos.x, centerPos.y);
                fieldCtx.lineTo(endX, endY);
                fieldCtx.stroke();
                
                // Arrow head
                const headLength = 15;
                const headAngle = 0.5;
                
                fieldCtx.beginPath();
                fieldCtx.moveTo(endX, endY);
                fieldCtx.lineTo(
                    endX - headLength * Math.cos(arrowAngle - headAngle),
                    endY - headLength * Math.sin(arrowAngle - headAngle)
                );
                fieldCtx.moveTo(endX, endY);
                fieldCtx.lineTo(
                    endX - headLength * Math.cos(arrowAngle + headAngle),
                    endY - headLength * Math.sin(arrowAngle + headAngle)
                );
                fieldCtx.stroke();
            }
            
            // Update center field display
            document.getElementById('centerField').textContent = centerFieldMag.toFixed(2);
            const centerAngle = Math.atan2(-centerField.y, centerField.x) * 180 / Math.PI;
            document.getElementById('centerAngle').textContent = centerAngle.toFixed(1);
        }
        
        // Draw distance scale/grid
        function drawDistanceScale() {
            const centerHeight = towerHeight - 6;
            const centerPos = worldToScreen(0, centerHeight);
            
            // Draw concentric circles at 10m, 20m, 30m, 40m, 50m intervals
            fieldCtx.strokeStyle = '#CCCCCC';
            fieldCtx.lineWidth = 1;
            fieldCtx.setLineDash([5, 5]); // Dashed lines
            
            for (let distance = 10; distance <= 50; distance += 10) {
                const radius = distance * pixelsPerMeter;
                
                fieldCtx.beginPath();
                fieldCtx.arc(centerPos.x, centerPos.y, radius, 0, TWO_PI);
                fieldCtx.stroke();
                
                // Add single distance label at optimal position
                fieldCtx.fillStyle = '#444444';
                fieldCtx.font = 'bold 14px Arial';
                fieldCtx.textAlign = 'center';
                fieldCtx.textBaseline = 'middle';
                
                // Choose best label position based on circle size and canvas bounds
                let labelX, labelY;
                
                // Consistent positioning for ALL distance labels - same direction as 40m
                const angle = Math.PI / 4; // 45 degrees down-right (same as 40m, 50m)
                labelX = centerPos.x + Math.cos(angle) * radius;
                labelY = centerPos.y + Math.sin(angle) * radius;
                
                // Only draw label if it's within reasonable bounds
                if (labelX > 20 && labelX < fieldWidth - 20 && 
                    labelY > 20 && labelY < fieldHeight - 20) {
                    
                    // Add background circle for better readability
                    fieldCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    fieldCtx.beginPath();
                    fieldCtx.arc(labelX, labelY, 12, 0, TWO_PI);
                    fieldCtx.fill();
                    
                    // Draw text
                    fieldCtx.fillStyle = '#444444';
                    fieldCtx.fillText(`${distance}m`, labelX, labelY);
                }
            }
            
            // Reset line dash
            fieldCtx.setLineDash([]);
            
            // Draw horizontal and vertical reference lines through center
            fieldCtx.strokeStyle = '#BBBBBB';
            fieldCtx.lineWidth = 1;
            fieldCtx.setLineDash([3, 3]);
            
            // Horizontal line
            fieldCtx.beginPath();
            fieldCtx.moveTo(0, centerPos.y);
            fieldCtx.lineTo(fieldWidth, centerPos.y);
            fieldCtx.stroke();
            
            // Vertical line
            fieldCtx.beginPath();
            fieldCtx.moveTo(centerPos.x, 0);
            fieldCtx.lineTo(centerPos.x, fieldHeight);
            fieldCtx.stroke();
            
            // Reset line dash
            fieldCtx.setLineDash([]);
        }
        
        // Draw linear distance markers at bottom-left
        function drawLinearDistanceMarkers() {
            const startX = 20; // Start position from left edge
            const startY = fieldHeight - 60; // Position from bottom
            const scaleLength = 80; // Total length of scale
            
            // Draw scale line
            fieldCtx.strokeStyle = '#333333';
            fieldCtx.lineWidth = 2;
            fieldCtx.beginPath();
            fieldCtx.moveTo(startX, startY);
            fieldCtx.lineTo(startX + scaleLength, startY);
            fieldCtx.stroke();
            
            // Draw markers for 10m, 20m, 30m
            const distances = [10, 20, 30];
            const pixelsPerUnit = scaleLength / 30; // 30m total scale
            
            distances.forEach(distance => {
                const x = startX + (distance * pixelsPerUnit);
                
                // Draw tick mark
                fieldCtx.beginPath();
                fieldCtx.moveTo(x, startY - 5);
                fieldCtx.lineTo(x, startY + 5);
                fieldCtx.stroke();
                
                // Draw label with background (with fallback for roundRect) - positioned clearly above the line
                fieldCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                fieldCtx.beginPath();
                if (fieldCtx.roundRect) {
                    fieldCtx.roundRect(x - 15, startY - 35, 30, 15, 3);
                } else {
                    fieldCtx.rect(x - 15, startY - 35, 30, 15);
                }
                fieldCtx.fill();
                
                // Draw text - positioned clearly above the line
                fieldCtx.fillStyle = '#333333';
                fieldCtx.font = 'bold 12px Arial';
                fieldCtx.textAlign = 'center';
                fieldCtx.textBaseline = 'middle';
                fieldCtx.fillText(`${distance}m`, x, startY - 27);
            });
            
            // Add scale title
            fieldCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            fieldCtx.beginPath();
            if (fieldCtx.roundRect) {
                fieldCtx.roundRect(startX + 10, startY + 10, 60, 15, 3);
            } else {
                fieldCtx.rect(startX + 10, startY + 10, 60, 15);
            }
            fieldCtx.fill();
            
            fieldCtx.fillStyle = '#333333';
            fieldCtx.font = 'bold 10px Arial';
            fieldCtx.textAlign = 'center';
            fieldCtx.fillText('Distance Scale', startX + 40, startY + 17);
        }
        
        // Draw secondary E-vector at 25m from center
        function drawSecondaryArrow() {
            const centerHeight = towerHeight - 6;
            const distance = 25; // 25m from center
            const angle = 0; // To the right of center (can be made configurable later)
            
            const vectorX = Math.cos(angle) * distance;
            const vectorY = centerHeight;
            const vectorPos = worldToScreen(vectorX, vectorY);
            
            // Calculate field at this position
            const field = calculateElectricField(vectorX, vectorY, time);
            const fieldMag = getFieldMagnitude(field.x, field.y);
            
            if (fieldMag > 0.001) { // Lower threshold for ultra-low field analysis
                // Arrow properties
                const maxArrowLength = 60;
                const arrowLength = Math.min(fieldMag * arrowScale * 1000, maxArrowLength); // 10x amplification vs red arrow
                const arrowAngle = Math.atan2(-field.y, field.x); // Negative y for screen coords
                
                // Arrow shaft
                const endX = vectorPos.x + Math.cos(arrowAngle) * arrowLength;
                const endY = vectorPos.y + Math.sin(arrowAngle) * arrowLength;
                
                fieldCtx.strokeStyle = '#0066FF'; // Blue color to distinguish from center arrow
                fieldCtx.lineWidth = 4;
                fieldCtx.beginPath();
                fieldCtx.moveTo(vectorPos.x, vectorPos.y);
                fieldCtx.lineTo(endX, endY);
                fieldCtx.stroke();
                
                // Arrow head
                const headLength = 12;
                const headAngle = 0.5;
                
                fieldCtx.beginPath();
                fieldCtx.moveTo(endX, endY);
                fieldCtx.lineTo(
                    endX - headLength * Math.cos(arrowAngle - headAngle),
                    endY - headLength * Math.sin(arrowAngle - headAngle)
                );
                fieldCtx.moveTo(endX, endY);
                fieldCtx.lineTo(
                    endX - headLength * Math.cos(arrowAngle + headAngle),
                    endY - headLength * Math.sin(arrowAngle + headAngle)
                );
                fieldCtx.stroke();
            }
            
            // Draw position marker
            fieldCtx.beginPath();
            fieldCtx.arc(vectorPos.x, vectorPos.y, 4, 0, TWO_PI);
            fieldCtx.fillStyle = '#0066FF';
            fieldCtx.fill();
            fieldCtx.strokeStyle = '#FFFFFF';
            fieldCtx.lineWidth = 2;
            fieldCtx.stroke();
            
            // Add label - compare single point vs averaged value
            const averagedFieldMag = sampleFieldAtDistance(25, time);
            fieldCtx.fillStyle = '#0066FF';
            fieldCtx.font = 'bold 12px Arial';
            fieldCtx.textAlign = 'center';
            fieldCtx.textBaseline = 'bottom';
            fieldCtx.fillText(`25m: ${fieldMag.toFixed(3)} kV/m (avg: ${averagedFieldMag.toFixed(3)})`, vectorPos.x, vectorPos.y - 10);
        }
        
        // Draw ground-level E-vector at 48.7m from center  
        function drawGroundLevelArrow() {
            const groundHeight = 2; // 2m above ground for safety analysis
            const distance = 30; // 30m horizontal distance (actual distance = 48.7m)
            const angle = 35 * Math.PI / 180; // 35 degrees (bottom-right, visible position)
            
            const vectorX = Math.cos(angle) * distance;
            const vectorY = groundHeight;
            const vectorPos = worldToScreen(vectorX, vectorY);
            
            // Calculate field at this position
            const field = calculateElectricField(vectorX, vectorY, time);
            const fieldMag = getFieldMagnitude(field.x, field.y);
            
            if (fieldMag > 0.0001) { // Even lower threshold for ultra-low field analysis
                // Arrow properties
                const maxArrowLength = 80;
                const arrowLength = Math.min(fieldMag * arrowScale * 10000, maxArrowLength); // 100x amplification vs red arrow
                const arrowAngle = Math.atan2(-field.y, field.x); // Negative y for screen coords
                
                // Arrow shaft
                const endX = vectorPos.x + Math.cos(arrowAngle) * arrowLength;
                const endY = vectorPos.y + Math.sin(arrowAngle) * arrowLength;
                
                fieldCtx.strokeStyle = '#00AA00'; // Green color for ground-level analysis
                fieldCtx.lineWidth = 3;
                fieldCtx.beginPath();
                fieldCtx.moveTo(vectorPos.x, vectorPos.y);
                fieldCtx.lineTo(endX, endY);
                fieldCtx.stroke();
                
                // Arrow head
                const headLength = 10;
                const headAngle = 0.5;
                
                fieldCtx.beginPath();
                fieldCtx.moveTo(endX, endY);
                fieldCtx.lineTo(
                    endX - headLength * Math.cos(arrowAngle - headAngle),
                    endY - headLength * Math.sin(arrowAngle - headAngle)
                );
                fieldCtx.moveTo(endX, endY);
                fieldCtx.lineTo(
                    endX - headLength * Math.cos(arrowAngle + headAngle),
                    endY - headLength * Math.sin(arrowAngle + headAngle)
                );
                fieldCtx.stroke();
            }
            
            // Draw position marker
            fieldCtx.beginPath();
            fieldCtx.arc(vectorPos.x, vectorPos.y, 4, 0, TWO_PI);
            fieldCtx.fillStyle = '#00AA00';
            fieldCtx.fill();
            fieldCtx.strokeStyle = '#FFFFFF';
            fieldCtx.lineWidth = 2;
            fieldCtx.stroke();
            
            // Add label - no background
            fieldCtx.fillStyle = '#00AA00';
            fieldCtx.font = 'bold 11px Arial';
            fieldCtx.textAlign = 'center';
            fieldCtx.textBaseline = 'middle';
            // Calculate actual distance from center point
            const centerHeight = towerHeight - 6;
            const actualDistance = Math.sqrt(vectorX * vectorX + (vectorY - centerHeight) * (vectorY - centerHeight));
            fieldCtx.fillText(`${actualDistance.toFixed(1)}m: ${fieldMag.toFixed(3)} kV/m`, vectorPos.x, vectorPos.y - 25);
        }
        
        // Draw plot sampling path indicator
        function drawPlotPath() {
            const centerHeight = towerHeight - 6;
            const centerPos = worldToScreen(0, centerHeight);
            const angle = 315 * Math.PI / 180; // 315 degrees
            
            // Draw dashed line showing sampling path
            fieldCtx.strokeStyle = '#FF8C00'; // Orange color
            fieldCtx.lineWidth = 2;
            fieldCtx.setLineDash([8, 4]); // Dashed line pattern
            
            // Draw line from center to maximum plot distance
            const maxDistance = plotEndDistance;
            const endX = Math.cos(angle) * maxDistance;
            const endY = centerHeight + Math.sin(angle) * maxDistance;
            const endPos = worldToScreen(endX, endY);
            
            fieldCtx.beginPath();
            fieldCtx.moveTo(centerPos.x, centerPos.y);
            fieldCtx.lineTo(endPos.x, endPos.y);
            fieldCtx.stroke();
            
            // Reset line dash
            fieldCtx.setLineDash([]);
            
            // Draw sample point markers at key distances
            const sampleDistances = [10, 20, 30, 40, 50];
            
            sampleDistances.forEach(distance => {
                if (distance <= maxDistance) {
                    const sampleX = Math.cos(angle) * distance;
                    const sampleY = centerHeight + Math.sin(angle) * distance;
                    const samplePos = worldToScreen(sampleX, sampleY);
                    
                    // Draw small circle marker
                    fieldCtx.fillStyle = '#FF8C00';
                    fieldCtx.beginPath();
                    fieldCtx.arc(samplePos.x, samplePos.y, 3, 0, TWO_PI);
                    fieldCtx.fill();
                    
                    // Draw white outline for visibility
                    fieldCtx.strokeStyle = '#FFFFFF';
                    fieldCtx.lineWidth = 1;
                    fieldCtx.stroke();
                }
            });
            
            // Add label for the path
            const labelDistance = 15; // Position label at 15m along the line
            const labelX = Math.cos(angle) * labelDistance;
            const labelY = centerHeight + Math.sin(angle) * labelDistance;
            const labelPos = worldToScreen(labelX, labelY);
            
            // Label background
            fieldCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            fieldCtx.fillRect(labelPos.x - 35, labelPos.y - 10, 70, 15);
            fieldCtx.strokeStyle = '#FF8C00';
            fieldCtx.lineWidth = 1;
            fieldCtx.strokeRect(labelPos.x - 35, labelPos.y - 10, 70, 15);
            
            // Label text
            fieldCtx.fillStyle = '#FF8C00';
            fieldCtx.font = 'bold 10px Arial';
            fieldCtx.textAlign = 'center';
            fieldCtx.textBaseline = 'middle';
            fieldCtx.fillText('Plot Path', labelPos.x, labelPos.y - 2);
        }
        
        // Draw arrow scaling legend
        function drawScalingLegend() {
            const legendX = fieldWidth - 20;
            const legendY = 30;
            
            // Background
            fieldCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            fieldCtx.fillRect(legendX - 140, legendY - 15, 135, 70);
            fieldCtx.strokeStyle = '#333';
            fieldCtx.lineWidth = 1;
            fieldCtx.strokeRect(legendX - 140, legendY - 15, 135, 70);
            
            // Title
            fieldCtx.fillStyle = '#333';
            fieldCtx.font = 'bold 12px Arial';
            fieldCtx.textAlign = 'left';
            fieldCtx.fillText('Arrow Scale:', legendX - 135, legendY);
            
            // Red arrow info
            fieldCtx.fillStyle = '#FF0000';
            fieldCtx.fillText('■ Red: 1x (Base)', legendX - 135, legendY + 15);
            
            // Blue arrow info  
            fieldCtx.fillStyle = '#0066FF';
            fieldCtx.fillText('■ Blue: 10x', legendX - 135, legendY + 30);
            
            // Green arrow info
            fieldCtx.fillStyle = '#00AA00';
            fieldCtx.fillText('■ Green: 100x', legendX - 135, legendY + 45);
        }
        
        // Draw field magnitude plot
        function drawFieldPlot() {
            const centerHeight = towerHeight - 6;
            
            // Clear plot canvas
            plotCtx.clearRect(0, 0, plotWidth, plotHeight);
            
            // Plot margins
            const margin = 60;
            const plotAreaWidth = plotWidth - 2 * margin;
            const plotAreaHeight = plotHeight - 2 * margin;
            
            // Sample field at different distances
            const distances = [];
            const magnitudes = [];
            const numSamples = 5000; // Ultra-high resolution for perfect Y-axis scaling
            
            for (let i = 0; i < numSamples; i++) {
                const distance = plotStartDistance + (plotEndDistance - plotStartDistance) * i / (numSamples - 1);
                const magnitude = sampleFieldAtDistance(distance, 0); // Fixed time for consistent plot data
                distances.push(distance);
                magnitudes.push(magnitude);
            }
            
            // Natural field data - no artificial smoothing modifications
            
            // Use fixed Y-axis scaling instead of auto-scaling
            const maxMag = plotMaxField;
            
            // Draw axes
            plotCtx.strokeStyle = '#333';
            plotCtx.lineWidth = 2;
            plotCtx.beginPath();
            // X-axis
            plotCtx.moveTo(margin, plotHeight - margin);
            plotCtx.lineTo(plotWidth - margin, plotHeight - margin);
            // Y-axis
            plotCtx.moveTo(margin, margin);
            plotCtx.lineTo(margin, plotHeight - margin);
            plotCtx.stroke();
            
            // Draw grid
            plotCtx.strokeStyle = '#ddd';
            plotCtx.lineWidth = 1;
            
            // Vertical grid lines - match 10m intervals
            for (let i = 0; i <= 5; i++) {
                const distance = i * 10;
                const x = margin + (plotAreaWidth * distance / (plotEndDistance - plotStartDistance));
                plotCtx.beginPath();
                plotCtx.moveTo(x, margin);
                plotCtx.lineTo(x, plotHeight - margin);
                plotCtx.stroke();
            }
            
            // Horizontal grid lines
            for (let i = 0; i <= 10; i++) {
                const y = margin + (plotAreaHeight * i / 10);
                plotCtx.beginPath();
                plotCtx.moveTo(margin, y);
                plotCtx.lineTo(plotWidth - margin, y);
                plotCtx.stroke();
            }
            
            // Draw field magnitude curve
            plotCtx.strokeStyle = '#0066CC';
            plotCtx.lineWidth = 3;
            plotCtx.beginPath();
            
            for (let i = 0; i < distances.length; i++) {
                const x = margin + (distances[i] - plotStartDistance) / (plotEndDistance - plotStartDistance) * plotAreaWidth;
                const normalizedMag = magnitudes[i] / maxMag; // Pure Y-axis scaling, no clipping
                const y = plotHeight - margin - normalizedMag * plotAreaHeight;
                
                // Draw all points - let canvas handle clipping naturally
                if (i === 0) {
                    plotCtx.moveTo(x, y);
                } else {
                    plotCtx.lineTo(x, y);
                }
            }
            plotCtx.stroke();
            
            // Draw labels
            plotCtx.fillStyle = '#333';
            plotCtx.font = '12px Arial';
            plotCtx.textAlign = 'center';
            
            // X-axis labels - use 10m intervals with better positioning
            for (let i = 0; i <= 5; i++) {
                const distance = i * 10; // 0, 10, 20, 30, 40, 50m
                const x = margin + (plotAreaWidth * distance / (plotEndDistance - plotStartDistance));
                
                // Ensure labels stay within canvas bounds
                if (x >= margin && x <= plotWidth - margin) {
                    plotCtx.fillText(distance + 'm', x, plotHeight - margin + 20);
                }
            }
            
            // Y-axis labels
            plotCtx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const magnitude = (maxMag * i / 5);
                const y = plotHeight - margin - (plotAreaHeight * i / 5);
                plotCtx.fillText(magnitude.toFixed(3), margin - 10, y + 4); // Show 3 decimal places for low values
            }
            
            // Axis titles
            plotCtx.textAlign = 'center';
            plotCtx.font = '14px Arial';
            plotCtx.fillText('Distance from Center (m)', plotWidth / 2, plotHeight - 20);
            
            plotCtx.save();
            plotCtx.translate(20, plotHeight / 2);
            plotCtx.rotate(-Math.PI / 2);
            plotCtx.fillText('Field Magnitude (kV/m)', 0, 0);
            plotCtx.restore();
            
            // Title
            plotCtx.textAlign = 'center';
            plotCtx.font = 'bold 16px Arial';
            plotCtx.fillText('Electric Field vs Distance', plotWidth / 2, 30);
            
            // Mark conductor position at 9m
            const conductor9mX = margin + (9 / (plotEndDistance - plotStartDistance)) * plotAreaWidth;
            plotCtx.strokeStyle = '#FF6600';
            plotCtx.lineWidth = 2;
            plotCtx.setLineDash([4, 4]);
            plotCtx.beginPath();
            plotCtx.moveTo(conductor9mX, margin);
            plotCtx.lineTo(conductor9mX, plotHeight - margin);
            plotCtx.stroke();
            plotCtx.setLineDash([]);
            
            // Label for conductor position
            plotCtx.fillStyle = '#FF6600';
            plotCtx.font = '10px Arial';
            plotCtx.textAlign = 'left';
            plotCtx.fillText('Conductors', conductor9mX + 2, margin + 15);
        }
        
        // Main render function
        function render() {
            // Clear and draw field canvas
            const gradient = fieldCtx.createLinearGradient(0, 0, 0, fieldHeight);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.7, '#E0F6FF');
            gradient.addColorStop(1, '#C8D6C8');
            fieldCtx.fillStyle = gradient;
            fieldCtx.fillRect(0, 0, fieldWidth, fieldHeight);
            
            drawGround();
            drawDistanceScale();
            drawPlotPath();
            drawTower();
            drawConductors();
            drawCentralArrow();
            drawSecondaryArrow();
            drawGroundLevelArrow();
            drawScalingLegend();
        }
        
        // Animation loop
        function animate(currentTime) {
            if (!isPaused) {
                // Smooth time progression without jumps
                if (startTime === 0) startTime = currentTime; // Initialize on first frame
                const elapsedSeconds = (currentTime - startTime) / 1000;
                time = elapsedSeconds * timeScale;
                
                // Always render vectors for perfectly smooth animation
                render();
                
                // Only update text displays at controlled rate for performance
                if (currentTime - lastUpdateTime >= updateInterval) {
                    lastUpdateTime = currentTime;
                    // Update time display at controlled rate
                    document.getElementById('timeDisplay').textContent = time.toFixed(3);
                    document.getElementById('circuit2Phase').textContent = phaseOffsetDegrees.toFixed(0);
                }
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Event handlers
        document.getElementById('playPauseBtn').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'Play' : 'Pause';
            
            if (!isPaused) {
                // Reset start time to current time to avoid jumps when resuming
                startTime = performance.now() - (time / timeScale * 1000);
                lastUpdateTime = performance.now();
            }
        });
        
        document.getElementById('resetBtn').addEventListener('click', function() {
            time = 0;
            startTime = 0; // Will be reset on next frame
            lastUpdateTime = 0;
            render();
            drawFieldPlot();
        });
        
        document.getElementById('circuit1Btn').addEventListener('click', function() {
            circuit1Active = !circuit1Active;
            this.textContent = `Circuit 1: ${circuit1Active ? 'ON' : 'OFF'}`;
            this.classList.toggle('off', !circuit1Active);
            render();
            drawFieldPlot();
        });
        
        document.getElementById('circuit2Btn').addEventListener('click', function() {
            circuit2Active = !circuit2Active;
            this.textContent = `Circuit 2: ${circuit2Active ? 'ON' : 'OFF'}`;
            this.classList.toggle('off', !circuit2Active);
            render();
            drawFieldPlot();
        });
        
        
        document.getElementById('phaseOffsetSlider').addEventListener('input', function() {
            phaseOffsetDegrees = parseInt(this.value);
            document.getElementById('phaseOffsetValue').textContent = this.value;
            render();
            drawFieldPlot();
        });
        
        
        document.getElementById('frequencySlider').addEventListener('input', function() {
            frequency = parseInt(this.value);
            omega = TWO_PI * frequency;
            document.getElementById('frequencyValue').textContent = this.value;
        });
        
        
        document.getElementById('plotStartSlider').addEventListener('input', function() {
            plotStartDistance = parseInt(this.value);
            document.getElementById('plotStartValue').textContent = this.value;
            render();
            drawFieldPlot();
        });
        
        document.getElementById('plotEndSlider').addEventListener('input', function() {
            plotEndDistance = parseInt(this.value);
            document.getElementById('plotEndValue').textContent = this.value;
            render();
            drawFieldPlot();
        });
        
        document.getElementById('plotMaxFieldSlider').addEventListener('input', function() {
            plotMaxField = parseFloat(this.value);
            document.getElementById('plotMaxFieldValue').textContent = this.value;
            drawFieldPlot(); // Pure Y-axis scaling - no need to redraw arrows
        });
        
        // Initial render and start animation
        render();
        drawFieldPlot(); // Initial plot draw
        animate(performance.now());
    </script>
</body>
</html>